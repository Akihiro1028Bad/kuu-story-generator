# Feature Specification: ストレージベースのアップロード・URLベースのアーキテクチャ

**Feature Branch**: `001-storage-upload`  
**Created**: 2025-01-27  
**Status**: Draft  
**Input**: User description: "アップロードは直接ストレージへ、Server Action は「URLだけ受け取る」、生成結果もURLだけ返す、UIはURLで表示/ダウンロード"

## Clarifications

### Session 2025-01-27

- Q: ストレージサービスの選択 → A: Vercel Blob（Vercel のネイティブストレージ）
- Q: アップロードURLの取得方法 → A: クライアント側で `upload()` を使用（サーバー側で `handleUpload()` を実装）
- Q: 不要ファイルの削除タイミング → A: 生成完了後に元画像を削除（生成結果が正常に取得できた場合のみ）
- Q: 生成結果の画像をストレージに保存する方法 → A: BFF API側（サーバー側）で `put()` メソッドを使用
- Q: Gemini APIの生成結果の形式 → A: base64 エンコードされた文字列（`candidates[0].content.parts[].inlineData.data` フィールド）。既存実装と公式ドキュメントで確認済み
- Q: Gemini APIからのbase64レスポンスがVercelの制限を超える可能性 → A: Vercelのリクエストボディ制限（4.5MB）は影響しない（レスポンスボディにはURLのみで数百バイト程度）。Next.jsの`responseLimit`は警告のみで実際の制限ではない。ただし、約3.38MB以上の元画像サイズに相当するbase64レスポンスの場合、BFF API側でのメモリ処理に注意が必要（実装時に監視・最適化を検討、必要に応じてメモリ設定を調整）
- Q: Server Actionが画像URLを受け取る方法 → A: FormDataにURLを文字列として含める（`formData.get('imageUrl')`）。Next.jsの標準的なパターンに一致し、既存の実装パターンと一貫性がある。他のフォームフィールド（textPhraseId、styleIdsなど）も同じFormDataに含められるため、統一的に扱える
- Q: BFF APIが画像URLを受け取る方法 → A: Server ActionからBFF APIを呼び出す際、FormDataに`imageUrl`を文字列として含める（`formData.get('imageUrl')`）。Server ActionとBFF APIの間でも一貫性があり、既存の実装パターンと一致する
- Q: BFF APIが画像URLから画像を取得してGemini APIに送る方法 → A: BFF API側で画像URLから画像をダウンロードし、base64に変換して`inlineData`としてGemini APIに送る。Gemini APIの標準的な方法であり、公式ドキュメントの例と一致する。シンプルで実装が容易で、パフォーマンスも良好（1回のリクエストで完結）。Vercel Blobの画像サイズ（通常10MB以下）には適している
- Q: imageUrlの取得元 → A: Vercel Blobの公開URLに限定する。BFF API側でホストのallowlist検証を行い、Vercel Blob以外のURLは拒否する（SSRF対策）
- Q: アップロード完了後のURL取得方法 → A: `upload()`の戻り値から`url`プロパティを取得する（`const blob = await upload(...); const imageUrl = blob.url;`）。通常の表示・アクセス用URLであり、公式ドキュメントの例でも使用されている標準的な方法。`downloadUrl`は`content-disposition: attachment`ヘッダーを持つダウンロード専用URLで、常にダウンロードを強制するため、表示には不適切
- Q: アップロード中の中断処理 → A: アップロードをキャンセルし、ストレージに残ったファイルはクリーンアップしない（オプトアウト方式）。`abortSignal`を使用してアップロードを中断し、`BlobRequestAbortedError`を適切に処理する。ストレージに残ったファイルは定期的なクリーンアップ（Cron Jobなど）で対応する。Vercel Blobのドキュメントにも定期的なクリーンアップの例が提供されている。アップロードが中断された場合、`onUploadCompleted`コールバックが呼ばれないため、URLが取得できず削除できない

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 画像を直接ストレージにアップロードして生成を実行する (Priority: P1)

ユーザーは画像ファイルを選択すると、そのファイルが直接ストレージにアップロードされ、アップロード完了後に取得したURLを使って生成処理を実行できる。

**Why this priority**: アーキテクチャ変更の中核機能であり、他の機能の前提となるため。

**Independent Test**: 画像ファイルを選択し、ストレージへのアップロードが完了してURLが取得され、そのURLを使って生成処理が実行できれば、このユーザーストーリーの価値が単独で成立する。

**Acceptance Scenarios**:

1. **Given** 画像未選択の状態、**When** ユーザーが画像ファイルを選択する、**Then** ファイルが直接ストレージにアップロードされ、アップロード完了後にURLが取得される
2. **Given** ストレージへのアップロードが完了してURLが取得された状態、**When** ユーザーが生成を実行する、**Then** Server Actionは画像URLのみを受け取り、生成処理を実行する
3. **Given** 生成処理が完了した状態、**When** システムが生成結果を返す、**Then** 生成結果の画像URLのみが返される

---

### User Story 2 - 生成結果をURLで表示・ダウンロードする (Priority: P1)

ユーザーは生成完了後、生成結果の画像URLを使って画像を表示し、ダウンロードできる。

**Why this priority**: ユーザーが最終成果物を取得するための必須機能であり、アーキテクチャ変更の目的を達成するため。

**Independent Test**: 生成結果のURLを受け取り、そのURLを使って画像を表示し、ダウンロードできれば、このユーザーストーリーの価値が単独で成立する。

**Acceptance Scenarios**:

1. **Given** 生成処理が完了して画像URLが取得された状態、**When** ユーザーが結果画面を表示する、**Then** URLを使って画像が表示される
2. **Given** 生成結果の画像が表示されている状態、**When** ユーザーがダウンロードを実行する、**Then** URLから画像をダウンロードできる
3. **Given** スマホで生成結果が表示されている状態、**When** ユーザーが保存を実行する、**Then** URLから画像を取得してカメラロールに保存できる

---

### User Story 3 - アップロード・生成処理のエラーハンドリング (Priority: P2)

ユーザーはアップロードや生成処理でエラーが発生した場合、適切なエラーメッセージを受け取り、復帰できる。

**Why this priority**: エラー時のユーザー体験を確保し、操作を継続できるようにするため。

**Independent Test**: 代表的なエラーケース（アップロード失敗、ストレージ接続エラー、生成失敗）で、ユーザーが次に取るべき行動が明確に示され、操作を継続できることを確認できる。

**Acceptance Scenarios**:

1. **Given** 画像ファイルを選択した状態、**When** ストレージへのアップロードが失敗する、**Then** ユーザー向けのエラーメッセージが表示され、再試行または別ファイル選択に誘導される
2. **Given** アップロードが完了してURLが取得された状態、**When** 生成処理が失敗する、**Then** ユーザー向けのエラーメッセージが表示され、再試行または入力の見直しに誘導される
3. **Given** 生成結果のURLが無効になった状態、**When** ユーザーが画像を表示しようとする、**Then** 適切なエラーメッセージが表示され、再生成または別の操作に誘導される

---

### Edge Cases

- **アップロード中の中断**: ユーザーがアップロード中に画面遷移や操作を中断した場合、`abortSignal`を使用してアップロードをキャンセルし、`BlobRequestAbortedError`を適切に処理する。ストレージに残ったファイルは定期的なクリーンアップ（Cron Jobなど）で対応する（アップロードが中断された場合、`onUploadCompleted`コールバックが呼ばれないため、URLが取得できず削除できない）
- **URLの有効期限切れ**: 生成結果のURLが有効期限切れになった場合、ユーザーに適切な案内を表示し、再生成を促す
- **ストレージ接続エラー**: ストレージサービスへの接続が失敗した場合、ユーザーに分かりやすいエラーメッセージを表示し、再試行を促す
- **大容量ファイル**: 10MBを超えるファイルがアップロードされた場合、クライアント側で検証し、ユーザーに適切な案内を表示する
- **ネットワーク不安定**: アップロードや生成処理中にネットワークが不安定になった場合、適切なエラーハンドリングと再試行機能を提供する
- **同時アップロード**: ユーザーが複数の画像を同時にアップロードしようとした場合、適切に処理できる
- **削除失敗**: 生成完了後の元画像削除処理が失敗した場合、エラーログを記録するが、生成処理自体は成功として扱う（削除失敗は生成結果に影響しない）
- **大容量生成結果**: Gemini APIからのbase64レスポンスが大きい場合（約3.38MB以上の元画像サイズに相当）、BFF API側でのメモリ処理に注意が必要。ただし、レスポンスボディにはURLのみが含まれるため、Vercelのレスポンスサイズ制限には影響しない

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、ユーザーが選択した画像ファイルを直接ストレージにアップロードできなければならない
- **FR-002**: システムは、アップロード完了後に取得した画像URLを保持し、生成処理に使用できなければならない
- **FR-003**: システムは、Server Actionが画像URLのみを受け取り、ファイルオブジェクトを受け取らないようにしなければならない
- **FR-021**: システムは、Server ActionがFormDataから`formData.get('imageUrl')`で画像URLを文字列として取得できなければならない
- **FR-022**: システムは、BFF APIがFormDataから`formData.get('imageUrl')`で画像URLを文字列として取得できなければならない
- **FR-023**: システムは、BFF API側で画像URLから画像をダウンロードし、base64に変換して`inlineData`としてGemini APIに送ることができなければならない
- **FR-004**: システムは、生成処理の結果として画像URLのみを返し、データURLやファイルオブジェクトを返さないようにしなければならない
- **FR-005**: システムは、生成結果の画像URLを使って画像を表示できなければならない
- **FR-006**: システムは、生成結果の画像URLを使って画像をダウンロードできなければならない
- **FR-007**: システムは、スマホで生成結果の画像URLを使ってカメラロールに保存できなければならない
- **FR-008**: システムは、アップロード処理の進行状況をユーザーに表示できなければならない
- **FR-009**: システムは、アップロード失敗時にユーザー向けエラーメッセージを画面内に表示し、再試行導線（ボタン/リンク）を提示しなければならない
- **FR-010**: システムは、生成処理失敗時にユーザー向けエラーメッセージを画面内に表示し、再試行導線（ボタン/リンク）を提示しなければならない
- **FR-011**: システムは、生成結果のURLが無効になった場合、ユーザー向けエラーメッセージを画面内に表示し、再生成導線（ボタン/リンク）を提示しなければならない
- **FR-012**: システムは、画像ファイルのバリデーション（形式・サイズ）をクライアント側で実施し、ストレージにアップロードする前に検証しなければならない
- **FR-013**: システムは、生成処理が成功し、生成結果のURLが正常に取得できた場合にのみ、元画像ファイルをストレージから削除できなければならない
- **FR-017**: システムは、生成処理が失敗した場合、元画像ファイルをストレージに保持し、再試行を可能にしなければならない
- **FR-014**: システムは、ストレージへのアップロード時に適切な認証・認可を実施しなければならない
- **FR-015**: システムは、サーバー側で `handleUpload()` を実装し、クライアントトークンを生成できなければならない
- **FR-016**: システムは、クライアント側で `upload()` メソッドを使用して、サーバーから取得したトークンで直接ストレージにアップロードできなければならない
- **FR-024**: システムは、`upload()`メソッドの戻り値から`url`プロパティを取得して、アップロード完了後の画像URLを取得できなければならない（`const blob = await upload(...); const imageUrl = blob.url;`）
- **FR-025**: システムは、アップロード中にユーザーが中断した場合、`abortSignal`を使用してアップロードをキャンセルし、`BlobRequestAbortedError`を適切に処理できなければならない
- **FR-018**: システムは、BFF API側で生成結果（base64 データ）を Buffer に変換し、`put()` メソッドを使用して Vercel Blob に保存できなければならない
- **FR-019**: システムは、生成結果の保存が完了した後、保存された画像のURLを返さなければならない
- **FR-020**: システムは、Gemini APIからのbase64レスポンスが大きい場合でも、BFF API側で適切に処理できなければならない（メモリ効率を考慮した実装）
- **FR-026**: システムは、`imageUrl`がVercel Blobの公開URLであることをサーバー側で検証し、許可されたホスト以外は拒否しなければならない（SSRF対策）
- **FR-027**: システムは、アップロード元画像と生成結果画像の保存先を Vercel Blob に限定しなければならない
- **FR-028**: システムは、生成結果の画像URLが24時間以上有効となる保存ポリシーを適用しなければならない

### Key Entities

- **UploadedImageURL**: ストレージにアップロードされた画像のURL。生成処理の入力として使用される。有効期限やアクセス権限などの属性を持つ。
- **GeneratedImageURL**: 生成処理の結果として取得された画像のURL。表示・ダウンロード・保存に使用される。有効期限やアクセス権限などの属性を持つ。
- **StorageFile**: ストレージに保存されたファイル。ファイル名、パス、メタデータ（サイズ、形式、アップロード日時など）などの属性を持つ。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: ユーザーは画像ファイルを選択してからストレージへのアップロードが完了するまで、10秒以内に完了できる
- **SC-002**: アップロード完了後、生成処理を開始できるまでの待機時間は1秒以内である
- **SC-003**: 生成結果の画像URLを使って画像を表示・ダウンロードできる成功率は95%以上である
- **SC-004**: アップロードや生成処理のエラー発生時、ユーザーが次に取るべき行動が明確に示され、90%以上のユーザーが適切な対応を取れる
- **SC-005**: ストレージへのアップロード処理は、10MB以下の画像ファイルに対して5秒以内に完了する
- **SC-006**: 生成結果の画像URLは、生成完了後24時間以上有効である

## Assumptions

- ストレージサービスは Vercel Blob を使用する（Vercel のネイティブストレージサービス）
- アップロードには、クライアント側で `@vercel/blob/client` の `upload()` メソッドを使用し、サーバー側で `handleUpload()` を実装してクライアントトークンを生成する方式を採用する
- クライアント側の `upload()` は、サーバー側の `/api/upload` エンドポイントを呼び出してトークンを取得し、その後クライアントから直接 Vercel Blob にアップロードする
- `upload()`メソッドの戻り値から`url`プロパティを取得して、アップロード完了後の画像URLを取得する（`const blob = await upload(...); const imageUrl = blob.url;`）。`url`は通常の表示・アクセス用URLであり、公式ドキュメントの例でも使用されている標準的な方法。`downloadUrl`は`content-disposition: attachment`ヘッダーを持つダウンロード専用URLで、常にダウンロードを強制するため、表示には不適切
- サーバー側の `handleUpload()` では、`onBeforeGenerateToken` で認証・認可を実施し、`onUploadCompleted` でアップロード完了後の処理を実行する
- アップロード中にユーザーが中断した場合、`abortSignal`を使用してアップロードをキャンセルし、`BlobRequestAbortedError`を適切に処理する。ストレージに残ったファイルは定期的なクリーンアップ（Cron Jobなど）で対応する（アップロードが中断された場合、`onUploadCompleted`コールバックが呼ばれないため、URLが取得できず削除できない）
- 生成結果の画像URLは、Vercel Blob が提供する公開URLを使用する
- ストレージへのアップロードは、クライアント側から直接実行する（サーバー経由でファイルを転送しない）
- 生成結果の保存は、BFF API側（サーバー側）で `put()` メソッドを使用して実行する（クライアント側では保存しない）
- 生成結果は外部API（Gemini）から base64 エンコードされた文字列として取得される（`candidates[0].content.parts[].inlineData.data` フィールド）
- BFF API側で base64 文字列を `Buffer.from(base64String, 'base64')` で Buffer に変換し、`put()` メソッドで Vercel Blob に保存する
- 既存実装（`app/api/generate/route.ts`）と Gemini API 公式ドキュメントで、生成結果が base64 形式で返されることを確認済み
- Gemini APIからのbase64レスポンスは、元の画像サイズの約1.33倍のサイズになる（base64エンコードによる増加）
- Vercelのサーバーレス関数のリクエストボディサイズ制限は4.5MB（公式ドキュメントで確認済み）
- Next.jsの`responseLimit`は警告のみで、実際の制限ではない（デフォルト4MBで警告が表示されるが、サーバーレス環境ではVercelの制限に従う）
- BFF APIのレスポンスボディにはURLのみが含まれるため、レスポンスサイズは非常に小さく（通常数百バイト）、Vercelの制限に影響しない
- Gemini APIからのbase64レスポンスは、BFF API側でメモリ内で処理される（Bufferに変換してVercel Blobに保存）
- 元の画像サイズが約3.38MB以上の場合、base64エンコード後のサイズが4.5MBを超える可能性があるが、これはメモリ内での処理であり、レスポンスボディのサイズには影響しない
- 大容量base64レスポンスのメモリ処理については、実装時に監視・最適化を検討する（必要に応じてメモリ設定を調整）
- Vercel Blob の認証情報（API キー）は、サーバー側で安全に管理され、クライアント側には露出しない
- 生成結果の画像URLは、生成完了後一定期間（24時間以上）有効であることを想定する
- 元画像ファイルの削除は、生成処理が成功し、生成結果のURLが正常に取得できた場合にのみ実行する（生成失敗時は元画像を保持して再試行を可能にする）
- Server Actionは、FormDataに含まれる画像URLを`formData.get('imageUrl')`で文字列として取得する（Next.jsの標準的なパターンに一致）
- 画像URLは、他のフォームフィールド（textPhraseId、styleIds、positionIdなど）と同様に、同じFormDataオブジェクトに含められる
- BFF APIは、Server Actionから受け取るFormDataから`formData.get('imageUrl')`で画像URLを文字列として取得する（Server ActionとBFF APIの間でも一貫性がある）
- BFF API側で画像URLから画像をダウンロードし、base64に変換して`inlineData`としてGemini APIに送る（Gemini APIの標準的な方法であり、公式ドキュメントの例と一致する）
- 画像URLからのダウンロードとbase64変換は、`fetch(imageUrl)` → `arrayBuffer()` → `Buffer.from().toString('base64')` の流れで実装する
- この方法は、20MB以下の画像に適しており、Vercel Blobの画像サイズ（通常10MB以下）には十分対応できる
- Gemini APIへの送信は、`inlineData`形式を使用し、追加のAPIコール（Files APIの事前アップロード）は不要である
- `imageUrl` は Vercel Blob の公開URLに限定し、BFF API側でホストallowlist検証を実施する

## Breaking Changes / Compatibility

- `/api/generate` のレスポンスが `imageDataUrl` から `imageUrl` に変更されるため、既存のUI・保存導線はURLベースへ移行が必要
- 互換期間中は `imageUrl` を優先しつつ、`imageDataUrl` が残る場合にも動作するよう両対応を行う（段階的に `imageDataUrl` を廃止）

## Dependencies

- Vercel Blob の設定と統合
- `@vercel/blob` パッケージのインストール（サーバー側）
- `@vercel/blob/client` パッケージのインストール（クライアント側）
- サーバー側での `handleUpload()` 実装（API Route または Server Action）
  - `onBeforeGenerateToken` での認証・認可・バリデーション
  - `onUploadCompleted` でのアップロード完了後の処理
- クライアント側での `upload()` メソッドの使用
- Vercel Blob への認証・認可の実装（API キーの管理、環境変数の設定）
- BFF API側での生成結果保存機能（`put()` メソッドを使用）
  - 外部APIから取得した base64 データを Buffer に変換
  - Vercel Blob への保存処理
  - 保存完了後のURL取得
- 生成完了後の元画像ファイル削除機能（`del()` メソッドを使用）

## Out of Scope

- Vercel Blob の詳細設定（実装時に決定）
- Vercel Blob の認証・認可の詳細実装（実装時に決定）
- Vercel Blob の URL 有効期限の詳細設定（24時間以上の有効期間を満たす実装ポリシーの範囲内で決定）
- Vercel Blob 内のファイル管理機能（削除、整理など）の詳細実装（実装時に決定）
- 大容量base64レスポンスのメモリ最適化（実装時に必要に応じて検討）
